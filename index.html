<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wdth,wght@0,75..100,100..900;1,75..100,100..900&display=swap" rel="stylesheet">
    <style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  font-family: "Roboto", sans-serif;
}
body {
  background-color: #081E3F;
  color: white; /* Change this! */
  overflow: hidden;
}
html,body {
  height: 100%;
}
#card-grid {
  flex-grow: 1;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(0px,1fr));
}
.card {
  display: flex;
  flex-direction: column;
  text-align: center;
  border: 1cqb solid #B6862C
}
.data {
  display: flex;
  height: 100%;
  width: 100%;
  flex-direction: column; /* Change to row for wide displays */
  justify-content: space-evenly;
  text-align: center;
}
.card p, h2, h3 {
  font-weight: bold;
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-evenly;
}
.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  container-type: inline-size; <!-- allows dimensions to be added -->
}
.message-grid {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: space-evenly;
  font-size: 6cqi;
}
.message {
  font-size: 12cqh;
  text-align: center;
  font-width: condensed;
  white-space: nowrap;
}
.hr-gold {
  border: 1cqb solid #B6862C;
}
.parking-datum {
  display: flex;
  flex-direction: column;
  justify-content: space-evenly;
  height: 100%;
}
.parking-type {
  font-size: 10cqb;
}
.parking-value {
  font-size: 15cqb;
  color: #FFCC00;
}
.title {
  font-size: 18cqb;
}
    </style>
  </head>
  <body>
    <template id="card-template">
      <div class="card">
        <h1 class="title"></h1>
        <hr class="hr-gold">
        <div class="data"></div>
      </div>
    </template>
    <div class="container">
      <div id="card-grid"></div>
      <div class="message-grid">
        <img src="https://welcome.fiu.edu/_assets/images/stickers/sticker-paw-blue.svg" style="height: 12cqh;">
        <h2 class="message">Please link your plate!</h2>
      </div>
    </div>
    <script>
      let occupancyList = []; // All garages to be displayed
      let fullGarages = [];

      function getParams(){
        // Get the names of garages to be displayed
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('hide-message')) {
          document.getElementsByClassName("message-grid")[0].style = "display: none";
        }
        return urlParams.has('garages') ? urlParams.get('garages').split(",") : [ "Lot 1", "PG3", "PG5" ];
      }
      function filterData(garages, isSensors) {
        sensorsList = [ "PG1", "PG2", "PG4", "PG6" ];
        garageList = [];
        garages.forEach(function(garage){
          if (isSensors && sensorsList.includes(garage)) {
            garageList.push(garage)
          } else if (!isSensors && !sensorsList.includes(garage)){
            garageList.push(garage)
          }
        })
        return garageList;
      }
      function getData(garages, isSensors){
        // Open the occupancy file and pass it into parseData
        //TODO: refactor duplicate blocks
        if (isSensors) {
          var xhttp = new XMLHttpRequest();
          xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
              parseDataSensors(this, filterData(garages, true), false);
            }
          };
          xhttp.open("GET", "http://localhost:8080/garagecounts.xml", true);
          xhttp.send();
        } else {
          var xhttp = new XMLHttpRequest();
          xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
              parseData(this, filterData(garages, false), false);
            }
          };
          xhttp.open("GET", "http://localhost:8080/occupancy.xml", true);
          xhttp.send();
        } 
      }

      function formatName(zoneName){
        // Convert raw name to pretty name
        let nameFilter = new RegExp("PG[0-9]+|Lot [0-9]+|Parkview|MMC", "i")
        return zoneName.match(nameFilter)[0];
      }

      function resizeCards(){
        //Given a number of garages, resize text accordingly 
        // TODO: this should also resize based on the type of count
        numCards = document.getElementsByClassName("title").length;
        if (numCards == 1) {
          if (document.getElementsByClassName("parking-type").length == 1){
            // If not split lot 
            document.getElementsByClassName("title")[0].style = "font-size: 30cqb;";
            document.getElementsByClassName("parking-type")[0].style = "font-size: 15cqb;";
            document.getElementsByClassName("parking-value")[0].style = "font-size: 25cqb;";
          } else if (document.getElementsByClassName("parking-type").length == 2) {
            document.getElementsByClassName("data")[0].style = "flex-direction: row;";
            document.getElementsByClassName("title")[0].style = "font-size: 30cqb;";
            document.getElementsByClassName("parking-type")[0].style = "font-size: 15cqb;";
            document.getElementsByClassName("parking-value")[0].style = "font-size: 25cqb;";
            document.getElementsByClassName("parking-type")[1].style = "font-size: 15cqb;";
            document.getElementsByClassName("parking-value")[1].style = "font-size: 25cqb;";
          }
        } else if (numCards == 2) {
          for (var i = 0; i < 2; i++){
            card = document.getElementById("card-" + i);
            type = document.getElementById("card-" + i).getElementsByClassName("parking-type");
            value = document.getElementById("card-" + i).getElementsByClassName("parking-value");
            if (type.length == 1){
              type[0].style = "font-size: 14cqb;";
              value[0].style = "font-size: 22cqb;";
            }
          }
        }
      }

      function formatCountType(zoneName, available){
        // Create an object pairing count type with count value
        if (available <= 0){
          available = "Full"
        }
        if (zoneName.match("Lvls 1")) {
          return { "Other": available };
        } else if (zoneName.match("Lvls 3")) {
          return { "Student": available };
        } else {
          return {"Available Spaces": available};
        }
      }

      function getCountType(zoneName){
        if (zoneName.match("Lvls 1")) {
          return "lower";
        } else if (zoneName.match("Lvls 3")) {
          return "upper";
        } else {
          return "single";
        }
      }

      function garageIndex(occupancyList, displayName){
        // Find the index of the garage in the list, if none return -1
        for (var i = 0; i < occupancyList.length; i++){
          if (occupancyList[i].displayName == displayName){
            return i;
          }
        }
        return -1;
      }

      function parseData(xml, garages, getFull){
        // Parse occupancy file
        const xmlDoc = xml.responseXML;
        const items = xmlDoc.getElementsByTagName("Occupancy");

        for (var item of items) { // Loop through all xml elements
          const zoneName = item.getElementsByTagName("ParkingZoneName")[0].textContent; //take off format name!
          const displayName = formatName(zoneName);
          const capacity = parseInt(item.getElementsByTagName("Capacity")[0].textContent, 10);
          const vehicles = parseInt(item.getElementsByTagName("Vehicles")[0].textContent, 10);
          const available = capacity - vehicles < 0 ? 0 : capacity - vehicles;
          const occupancyIndex = garageIndex(occupancyList, displayName);

          garages.forEach(garageID => { 
            // Find if garage in xml file is located in `garages`.
            if (getFull) {
              if (available == 0 && !fullGarages.includes(displayName)){
                // If garage is full, add to fullGarages 
                fullGarages.push(displayName);
              }
            } else {
            // If so, add to occupancyList
              if (displayName.match(garageID + "$") && !zoneName.includes("Total")){
                if (zoneName.match("Lvls")) {
                  // Handle split garages
                  if (occupancyIndex >= 0) {
                    //If this is the second split occupancy entry (student or other), keep track of the existing count name and value
                    const curr = occupancyList[occupancyIndex]["available"];
                    if (getCountType(zoneName) == "upper")
                      //Upper floors should show up at the top
                      occupancyList[occupancyIndex]["available"] = {...formatCountType(zoneName, available), ...curr};
                    else
                      occupancyList[occupancyIndex]["available"] = {...curr, ...formatCountType(zoneName, available)};
                  } else {
                    // If this is the first split occupancy garage entry (student or other)
                    occupancyList.push({ zoneName, displayName, capacity, vehicles, available: formatCountType(zoneName, available)});
                  }
                } else {
                  occupancyList.push({ zoneName, displayName, capacity, vehicles, available: formatCountType(zoneName, available) });
                }
              }
            }
          });
        }
      }

      function parseDataSensors(xml, garages, getFull){
        // Parse sensor occupancy file
        const xmlDoc = xml.responseXML;
        const items = xmlDoc.getElementsByTagName("Garage");

        for (var item of items) {
          const garageName = item.getElementsByTagName("GarageName")[0].textContent; //take off format name!
          const displayName = formatName(garageName);

          const studentSpaces = parseInt(item.getElementsByTagName("StudentSpaces")[0].textContent, 10);
          const studentMax = parseInt(item.getElementsByTagName("StudentMax")[0].textContent, 10);
          const studentAvailable = { "Student": studentMax - studentSpaces <= 0 ? "Full" : studentMax - studentSpaces };

          const otherSpaces = parseInt(item.getElementsByTagName("OtherSpaces")[0].textContent, 10);
          const otherMax = parseInt(item.getElementsByTagName("OtherMax")[0].textContent, 10);
          const otherAvailable = { "Other": otherMax - otherSpaces <= 0 ? "Full" : otherMax - otherSpaces };

          garages.forEach(garageID => { 
            // Find if garage in xml file is located in `garages`.
            // If so, add to occupancyList
            if (getFull) {
              if (studentAvailable["Student"] == "Full" && !fullGarages.includes(displayName)){
                fullGarages.push(displayName);
              }
            } else {
              if (displayName.match(garageID + "$")){
                occupancyList.push({ garageName, displayName,
                  available: { ...studentAvailable, ...otherAvailable } });
              }
            }
          });
        }
      }

      function alignItemsByQuery() {
        // Ensure occupancyList is in the same order as the query string
        sortedList = [];
        garages = getParams();

        garages.forEach(garageID => {
          occupancyList.forEach(occupancy => {
            if (occupancy.displayName == garageID) {
              sortedList.push(occupancy);
            }
          });
        });
        return sortedList;
      }

      function setCounts() {
        const cardGrid = document.getElementById('card-grid');
        const cardFragment = document.createDocumentFragment();

        sortedList = alignItemsByQuery();
        // Add counts to UI
        for (var i = 0; i < sortedList.length; i++){
          insertCard(cardFragment, "card-" + i, sortedList[i].displayName, sortedList[i].available);
        }
        cardGrid.replaceChildren(cardFragment);
        resizeCards();
        occupancyList = [];
        fullGarages = [];
      }

      function insertCard(cardFragment, uniqueId, title, data) {
        // Add a card, where each card is a unique garage
        const template = document.getElementById("card-template");
        const clone = document.importNode(template.content, true);
        const card = clone.querySelector(".card");
        card.id = uniqueId;
        clone.querySelector(".title").textContent = title;

        for (const [key, value] of Object.entries(data)) {
          // Create a parking datum (type and value)
          const parkingDatum = document.createElement("div");
          parkingDatum.className = "parking-datum";
          // Create count type element (Student, Other)
          const parkingType = document.createElement("h3");
          parkingType.className = "parking-type";
          parkingType.textContent = key;
          // Create count number element (# of spaces)
          const parkingValue = document.createElement("p");
          parkingValue.className = "parking-value";
          parkingValue.textContent = value;

          parkingDatum.append(parkingType);
          parkingDatum.append(parkingValue);

          clone.querySelector(".data").append(parkingDatum);
        }
        cardFragment.append(clone);
      }
      setInterval(function() {
        getData(getParams(), true);
        getData(getParams(), false);
        setCounts();
      }, 5000);
    </script> 
  </body>
</html>
