<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wdth,wght@0,75..100,100..900;1,75..100,100..900&display=swap" rel="stylesheet">
    <style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  font-family: "Roboto", sans-serif;
}
body {
  background-color: #081E3F;
  color: white; /* Change this! */
  overflow: hidden;
}
html,body {
  height: 100%;
}
#card-grid {
  flex-grow: 1;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(0px,1fr));
}
.card {
  display: flex;
  flex-direction: column;
  text-align: center;
  border: 1cqb solid #B6862C
}
.data {
  display: flex;
  height: 100%;
  width: 100%;
  flex-direction: column; /* Change to row for wide displays */
  justify-content: space-evenly;
  text-align: center;
}
.card p, h2, h3 {
  font-weight: bold;
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-evenly;
}
.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  container-type: inline-size; <!-- allows dimensions to be added -->
}
.message-grid {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: space-evenly;
  font-size: 6cqi;
}
.message {
  font-size: 12cqh;
  text-align: center;
  font-width: condensed;
  white-space: nowrap;
}
.hr-gold {
  border: 1cqb solid #B6862C;
}
.parking-datum {
  display: flex;
  flex-direction: column;
  justify-content: space-evenly;
  height: 100%;
}
.parking-type {
  font-size: 10cqb;
}
.parking-value {
  font-size: 15cqb;
  color: #FFCC00;
}
.title {
  font-size: 18cqb;
}
    </style>
  </head>
  <body>
    <template id="card-template">
      <div class="card">
        <h1 class="title"></h1>
        <hr class="hr-gold">
        <div class="data"></div>
      </div>
    </template>
    <div class="container">
      <div id="card-grid"></div>
      <div class="message-grid">
        <img src="https://welcome.fiu.edu/_assets/images/stickers/sticker-paw-blue.svg" style="height: 12cqh;">
        <h2 class="message">Please link your plate!</h2>
      </div>
    </div>
    <script>
      let occupancyList = []; // All garages to be displayed
      let fullGarages = [];
      let garageParams = getParams();
      const dataSources = { "sensors": "http://localhost:8080/garagecounts.xml", "genetec": "http://localhost:8080/occupancy.xml" };
      const sensorsList = [ "PG1", "PG2", "PG4", "PG6" ]
      //TODO: Use less dynamic global variables

      function getParams(){
        // Get the names of garages to be displayed
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('hide-message')) {
          document.getElementsByClassName("message-grid")[0].style = "display: none";
        }
        return urlParams.has('garages') ? urlParams.get('garages').split(",") : [ "Lot 1", "PG5" ];
      }
      function filterData(garages, isSensors) {
        garageList = [];
        garages.forEach(function(garage){
          if (isSensors && sensorsList.includes(garage)) {
            garageList.push(garage)
          } else if (!isSensors && !sensorsList.includes(garage)){
            garageList.push(garage)
          }
        })
        return garageList;
      }
      async function fetchXML(type){
        var xmlText = "";
        const requestParams = {
          cache: "no-store",
          mode: "cors"
        };
        if (type == "sensors"){
          const response = await fetch(dataSources["sensors"], requestParams)
            .then(function (response) {
              return response.arrayBuffer();
            })
            .then(function (buffer) {
              const decoder = new TextDecoder('utf-16le');
              const text = decoder.decode(buffer);
              xmlText = text;
            }); // Sensor counts data is encoded in utf-16le and needs to be converted
        } else if (type == "genetec"){
          const response = await fetch(dataSources["genetec"], requestParams);
          xmlText = await response.text();
        }
        const parser = new DOMParser();
        xmlDoc = parser.parseFromString(xmlText, "application/xml");
        return xmlDoc;
      }

      function formatName(zoneName){
        // Convert raw name to pretty name
        let nameFilter = new RegExp("PG[0-9]+|Lot [0-9]+|Parkview|MMC", "i")
        return zoneName.match(nameFilter)[0];
      }

      function resizeCards(){
        //Given a number of garages, resize text accordingly 
        // TODO: this should also resize based on the type of count
        numCards = document.getElementsByClassName("title").length;
        if (numCards == 1) {
          if (document.getElementsByClassName("parking-type").length == 1){
            // If not split lot 
            document.getElementsByClassName("title")[0].style = "font-size: 30cqb;";
            document.getElementsByClassName("parking-type")[0].style = "font-size: 15cqb;";
            document.getElementsByClassName("parking-value")[0].style = "font-size: 25cqb;";
          } else if (document.getElementsByClassName("parking-type").length == 2) {
            document.getElementsByClassName("data")[0].style = "flex-direction: row;";
            document.getElementsByClassName("title")[0].style = "font-size: 30cqb;";
            document.getElementsByClassName("parking-type")[0].style = "font-size: 15cqb;";
            document.getElementsByClassName("parking-value")[0].style = "font-size: 25cqb;";
            document.getElementsByClassName("parking-type")[1].style = "font-size: 15cqb;";
            document.getElementsByClassName("parking-value")[1].style = "font-size: 25cqb;";
          }
        } else if (numCards == 2) {
          for (var i = 0; i < 2; i++){
            card = document.getElementById("card-" + i);
            type = document.getElementById("card-" + i).getElementsByClassName("parking-type");
            value = document.getElementById("card-" + i).getElementsByClassName("parking-value");
            if (type.length == 1){
              type[0].style = "font-size: 14cqb;";
              value[0].style = "font-size: 22cqb;";
            }
          }
        }
      }

      function formatCountType(zoneName, available){
        // Create an object pairing count type with count value
        if (available <= 0){
          available = "Full"
        }
        if (zoneName.match("Lvls 1")) {
          return { "Other": available };
        } else if (zoneName.match("Lvls 3")) {
          return { "Student": available };
        } else {
          return {"Available Spaces": available};
        }
      }

      function getCountType(zoneName){
        if (zoneName.match("Lvls 1")) {
          return "lower";
        } else if (zoneName.match("Lvls 3")) {
          return "upper";
        } else {
          return "single";
        }
      }

      function garageIndex(occupancyList, displayName){
        // Find the index of the garage in the list, if none return -1
        for (var i = 0; i < occupancyList.length; i++){
          if (occupancyList[i].displayName == displayName){
            return i;
          }
        }
        return -1;
      }

      function getAlternativeGarage(garage){
        var garageGroupIndex = -1;
        var startIndex = -1;
        var swapIndex = -1;
        for (var i = 0; i < garageGroups.length; i++) {
          // Find the garage group that a garage belongs in
          const group = garageGroups[i];
          if (group.includes(garage)) {
            garageGroupIndex = i;
            startIndex = group.indexOf(garage);
            break;
          }
        }
        
        // If there exists a garage group, then execute below to find an alternate garage
        if (garageGroupIndex != -1){
          const group = garageGroups[garageGroupIndex]
          for (var i = 0; i < group.length; i++) {
            const currIndex = (startIndex + i) % group.length
            if (!garageParams.includes(group[currIndex]) && !fullGarages.includes(group[currIndex])){
              // If a swap candidate will already be displayed, skip to avoid duplicate count 
              // Also, if a swap candidate is full, skip it
              swapIndex = currIndex;
              break;
            } 
          }
        }
          
        // If we found an alternate garage, return it. Otherwise, return the same garage
        if (swapIndex != -1) {
          return garageGroups[garageGroupIndex][swapIndex];
        } else {
          return garage;
        }
      }

      function swapFullGarages(){
        fullGarages.forEach(garage => {
          const altGarage = getAlternativeGarage(garage);
          if (garageParams.includes(garage) && !garageParams.includes(altGarage) && garageParams.length < 3) {
            // Put a third alternative garage if one or more of garages to be displayed are full
            garageParams.push(altGarage);
          }
        });
      }

      function parseData(xml, garages, getFull){
        // Parse occupancy file
        const items = xml.getElementsByTagName("Occupancy");

        for (var item of items) { // Loop through all xml elements
          const zoneName = item.getElementsByTagName("ParkingZoneName")[0].textContent; //take off format name!
          const displayName = formatName(zoneName);
          const capacity = parseInt(item.getElementsByTagName("Capacity")[0].textContent, 10);
          const vehicles = parseInt(item.getElementsByTagName("Vehicles")[0].textContent, 10);
          const available = capacity - vehicles < 0 ? 0 : capacity - vehicles;
          const occupancyIndex = garageIndex(occupancyList, displayName);
          if (getFull) {
            if (available == 0 && getCountType(zoneName) == "upper" && !fullGarages.includes(displayName) && !sensorsList.includes(displayName)){
              // If garage is full, add to fullGarages 
              fullGarages.push(displayName);
            }
          } else {
            garages.forEach(garageID => { 
              // Find if garage in xml file is located in `garages`.
              // If so, add to occupancyList
              if (displayName.match(garageID + "$") && !zoneName.includes("Total")){
                if (zoneName.match("Lvls")) {
                  // Handle split garages
                  if (occupancyIndex >= 0) {
                    //If this is the second split occupancy entry (student or other), keep track of the existing count name and value
                    const curr = occupancyList[occupancyIndex]["available"];
                    if (getCountType(zoneName) == "upper")
                      //Upper floors should show up at the top
                      occupancyList[occupancyIndex]["available"] = {...formatCountType(zoneName, available), ...curr};
                    else
                      occupancyList[occupancyIndex]["available"] = {...curr, ...formatCountType(zoneName, available)};
                  } else {
                    // If this is the first split occupancy garage entry (student or other)
                    occupancyList.push({ zoneName, displayName, capacity, vehicles, available: formatCountType(zoneName, available)});
                  }
                } else {
                  occupancyList.push({ zoneName, displayName, capacity, vehicles, available: formatCountType(zoneName, available) });
                }
              }
            });
          }
        }
      }

      function parseDataSensors(xml, garages, getFull){
        // Parse sensor occupancy file
        const items = xml.getElementsByTagName("Garage");

        for (var item of items) {
          const garageName = item.getElementsByTagName("GarageName")[0].textContent; //take off format name!
          const displayName = formatName(garageName);

          const studentSpaces = parseInt(item.getElementsByTagName("StudentSpaces")[0].textContent, 10);
          const studentMax = parseInt(item.getElementsByTagName("StudentMax")[0].textContent, 10);
          const studentAvailable = { "Student": studentMax - studentSpaces <= 0 ? "Full" : studentMax - studentSpaces };

          const otherSpaces = parseInt(item.getElementsByTagName("OtherSpaces")[0].textContent, 10);
          const otherMax = parseInt(item.getElementsByTagName("OtherMax")[0].textContent, 10);
          const otherAvailable = { "Other": otherMax - otherSpaces <= 0 ? "Full" : otherMax - otherSpaces };
          if (getFull) {
            if (studentAvailable["Student"] == "Full" && !fullGarages.includes(displayName) && sensorsList.includes(displayName)){
              fullGarages.push(displayName);
            }
          } else {
          garages.forEach(garageID => { 
            // Find if garage in xml file is located in `garages`.
            // If so, add to occupancyList

              if (displayName.match(garageID + "$")){
                occupancyList.push({ garageName, displayName,
                  available: { ...studentAvailable, ...otherAvailable } });
              }
            });
          }
        }
      }

      function alignItemsByQuery() {
        // Ensure occupancyList is in the same order as the query string
        sortedList = [];

        garageParams.forEach(garageID => {
          occupancyList.forEach(occupancy => {
            if (occupancy.displayName == garageID) {
              sortedList.push(occupancy);
            }
          });
        });
        return sortedList;
      }

      function setCounts() {
        const cardGrid = document.getElementById('card-grid');
        const cardFragment = document.createDocumentFragment();

        sortedList = alignItemsByQuery();
        // Add counts to UI
        for (var i = 0; i < sortedList.length; i++){
          insertCard(cardFragment, "card-" + i, sortedList[i].displayName, sortedList[i].available);
        }
        cardGrid.replaceChildren(cardFragment);
        resizeCards();
        occupancyList = [];
        fullGarages = [];
      }

      function insertCard(cardFragment, uniqueId, title, data) {
        // Add a card, where each card is a unique garage
        const template = document.getElementById("card-template");
        const clone = document.importNode(template.content, true);
        const card = clone.querySelector(".card");
        card.id = uniqueId;
        clone.querySelector(".title").textContent = title;

        for (const [key, value] of Object.entries(data)) {
          // Create a parking datum (type and value)
          const parkingDatum = document.createElement("div");
          parkingDatum.className = "parking-datum";
          // Create count type element (Student, Other)
          const parkingType = document.createElement("h3");
          parkingType.className = "parking-type";
          parkingType.textContent = key;
          // Create count number element (# of spaces)
          const parkingValue = document.createElement("p");
          parkingValue.className = "parking-value";
          parkingValue.textContent = value;

          parkingDatum.append(parkingType);
          parkingDatum.append(parkingValue);

          clone.querySelector(".data").append(parkingDatum);
        }
        cardFragment.append(clone);
      }
      async function main(){
        garageParams = getParams();

        const fetchXMLs = await Promise.allSettled([fetchXML("genetec"), fetchXML("sensors")]);
        fetchXMLs.forEach(result => {
          // Populate fullGarages to keep track of full garages
          if (result.value.getElementsByTagName("OccupancyExport").length > 0){
            parseData(result.value, filterData(garageParams, false), true);
          } else if (result.value.getElementsByTagName("GarageCount").length > 0) {
            parseDataSensors(result.value, filterData(garageParams, true), true);
          }
        });
        swapFullGarages();

        fetchXMLs.forEach(result => {
          // Populate occupancyList with count data 
          if (result.value.getElementsByTagName("OccupancyExport").length > 0){
            parseData(result.value, filterData(garageParams, false), false);
          } else if (result.value.getElementsByTagName("GarageCount").length > 0) {
            parseDataSensors(result.value, filterData(garageParams, true), false);
          }
        });
        setCounts(); // Add the actual divs to display counts
        fullGarages = [];
      }
      main();
      setInterval(async () => {
        await main();
      }, 1000);
    </script> 
  </body>
</html>
